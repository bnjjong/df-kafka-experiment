# 1회차 직렬화 벤치마크 요약

## 테스트 개요
- 시나리오: `load-test:batch`
- 전송 건수: 1,000,000 건
- 지표: 프로듀서 요약 로그(`AdClickProducer summary`)에 기록된 평균/총합 값 활용

## 결과 표 (5회 평균)
| Serializer | Runs | 평균 메시지 크기 (Bytes) | 크기 표준편차 | 평균 전송 시간 (ms) | 전송시간 표준편차 |
| --- | --- | --- | --- | --- | --- |
| SPRING_JSON | 5 | 181.35 | 0.0000 | 3.078 | 0.182 |
| JACKSON_OBJECT_MAPPER | 5 | 190.34 | 0.0040 | 2.959 | 0.137 |
| KOTLINX_JSON | 5 | 190.34 | 0.0040 | 2.890 | 0.040 |

각 run의 원본 로그는 Appendix에서 확인할 수 있습니다.

### Appendix: 개별 실행 로그
| Serializer | 성공 건수 | 평균 메시지 크기 (Bytes) | 평균 전송 시간 (ms) | 총 메시지 크기 (Bytes) | 총 전송 시간 (ms) |
| --- | --- | --- | --- | --- | --- |
| SPRING_JSON | 1,000,000 | 181.35 | 3.436 | 181,347,890 | 3,436,416.307 |
| SPRING_JSON | 1,000,000 | 181.35 | 3.030 | 181,347,890 | 3,029,687.170 |
| SPRING_JSON | 1,000,000 | 181.35 | 2.956 | 181,347,890 | 2,956,009.903 |
| SPRING_JSON | 1,000,000 | 181.35 | 2.947 | 181,347,890 | 2,947,144.033 |
| SPRING_JSON | 1,000,000 | 181.35 | 3.019 | 181,347,890 | 3,018,893.744 |
| JACKSON_OBJECT_MAPPER | 1,000,000 | 190.34 | 3.202 | 190,344,849 | 3,201,744.897 |
| JACKSON_OBJECT_MAPPER | 1,000,000 | 190.35 | 2.795 | 190,345,034 | 2,794,933.224 |
| JACKSON_OBJECT_MAPPER | 1,000,000 | 190.34 | 2.888 | 190,344,880 | 2,888,144.269 |
| JACKSON_OBJECT_MAPPER | 1,000,000 | 190.34 | 2.919 | 190,344,970 | 2,919,462.359 |
| JACKSON_OBJECT_MAPPER | 1,000,000 | 190.34 | 2.993 | 190,344,880 | 2,993,105.897 |
| KOTLINX_JSON | 1,000,000 | 190.34 | 2.950 | 190,344,928 | 2,950,452.538 |
| KOTLINX_JSON | 1,000,000 | 190.34 | 2.914 | 190,344,872 | 2,913,595.245 |
| KOTLINX_JSON | 1,000,000 | 190.34 | 2.833 | 190,344,857 | 2,832,513.247 |
| KOTLINX_JSON | 1,000,000 | 190.35 | 2.887 | 190,345,020 | 2,886,529.231 |
| KOTLINX_JSON | 1,000,000 | 190.34 | 2.865 | 190,344,908 | 2,865,257.177 |

## 관찰 사항
- `SPRING_JSON`은 메시지 크기가 가장 작았으나 평균 전송 시간이 가장 오래 걸렸습니다.
- `JACKSON_OBJECT_MAPPER`는 크기가 증가했지만 평균 전송 시간이 `SPRING_JSON` 대비 3~4% 개선되었습니다.
- `KOTLINX_JSON`은 `JACKSON_OBJECT_MAPPER`와 유사한 메시지 크기를 유지하면서 가장 낮은 평균 전송 시간을 기록했습니다.

## 상세 분석
- **메시지 크기**
  - Spring의 `JsonSerializer`는 기본적으로 Jackson `ObjectMapper`를 공유하지만, 날짜 타입을 epoch milli(숫자)로 출력하는 Spring Boot 기본 설정 영향으로 `clickedAt` 필드가 짧게 표현된 것으로 보입니다. 반면 커스텀 Jackson/Kotlinx 구현은 ISO-8601 문자열 형태라 약 9바이트가 추가됐습니다.
  - 세 serializer 모두 필드 구조는 동일하므로 크기 차이는 주로 시간 필드 표현 방식에서 발생한 것으로 추정됩니다.
- **전송 소요 시간**
  - `SPRING_JSON`은 메시지를 직렬화할 때마다 내부적으로 `ObjectWriter` 준비와 `JsonGenerator` 설정을 반복하기 때문에 CPU 오버헤드가 가장 컸던 것으로 보입니다.
  - 직접 래핑한 `ObjectMapper`는 Spring 부트 설정이 적용된 인스턴스를 그대로 사용하므로 writer 재활용이 가능해 평균 지연이 7%가량 감소했습니다.
  - `KOTLINX_JSON`은 코틀린 컴파일 타임 메타데이터를 활용해 매핑 테이블을 미리 생성하므로 런타임 reflection 비용이 없고, 문자열 결합도 단순해 Jackson 대비 추가로 약 8% 속도 개선이 나타났습니다.
- **누적 시간**
  - 100만 건 기준 총 전송 시간 차이는 최대 약 486초(약 14%)까지 벌어졌습니다. `대용량 배치일수록 serializer 선택이 전체 지속시간에 의미 있는 영향`을 줄 수 있음을 시사합니다.
- **추가 확인 필요 사항**
  - 현재 결과는 애플리케이션 단일 실행 환경에서 얻은 값이므로 GC, JVM warm-up, 브로커 부하 등에 따라 변동될 수 있습니다. 반복 실험과 표준편차 산출을 통한 신뢰도 확보가 필요합니다.
  - ISO 문자열 대신 epoch milli를 사용하도록 Jackson/Kotlinx 설정을 통일하면 메시지 크기를 줄이면서 속도도 확보할 수 있는지 검토할 수 있습니다.

## 다음 액션 아이디어
1. 반복 테스트를 수행해 결과 안정성을 확인하고, 표준편차 등 변동성 지표를 추가 측정합니다.
2. 메시지 필드를 조정하거나 압축 옵션을 바꿔서 직렬화 전략의 상대적 강점을 재평가합니다.
3. 컨슈머 측 역직렬화 비용과도 연계 측정을 검토합니다.
